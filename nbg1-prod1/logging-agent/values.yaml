alloy:
  crds:
    create: false
  alloy:
    configMap:
      create: true
      content: |-
        // Discover all pod log files
        local.file_match "pods" {
          path_targets = [{
            __path__ = "/var/log/pods/*/*/*.log",
          }]
        }

        // Relabel to add pod metadata
        discovery.relabel "pod_logs" {
          targets = local.file_match.pods.targets

          // Extract namespace, pod name, UID, and container from the file path
          rule {
            source_labels = ["__path__"]
            regex         = "/var/log/pods/(?P<namespace>[^_]+)_(?P<pod>[^_]+)_(?P<uid>[^/]+)/(?P<container>[^/]+)/.*\\.log"
            target_label  = "namespace"
            replacement   = "$1"
          }

          rule {
            source_labels = ["__path__"]
            regex         = "/var/log/pods/(?P<namespace>[^_]+)_(?P<pod>[^_]+)_(?P<uid>[^/]+)/(?P<container>[^/]+)/.*\\.log"
            target_label  = "pod"
            replacement   = "$2"
          }

          rule {
            source_labels = ["__path__"]
            regex         = "/var/log/pods/(?P<namespace>[^_]+)_(?P<pod>[^_]+)_(?P<uid>[^/]+)/(?P<container>[^/]+)/.*\\.log"
            target_label  = "container"
            replacement   = "$4"
          }
        }

        // Read and parse the log files
        loki.source.file "pods" {
          targets    = discovery.relabel.pod_logs.output
          forward_to = [loki.write.default.receiver]
        }

        // Relabel syslog metadata to retain labels
        loki.relabel "talos_service_logs" {
          forward_to = [loki.write.default.receiver]

          rule {
            source_labels = ["__syslog_message_hostname"]
            target_label  = "hostname"
          }

          rule {
            source_labels = ["__syslog_message_severity"]
            target_label  = "severity"
          }

          rule {
            source_labels = ["talos-service"]
            target_label  = "service"
          }

          rule {
            source_labels = ["talos-level"]
            target_label  = "level"
          }

          rule {
            action = "labeldrop"
            regex  = "talos-.*"
          }
        }

        loki.relabel "talos_kernel_logs" {
          forward_to = [loki.write.default.receiver]

          rule {
            source_labels = ["__syslog_message_hostname"]
            target_label  = "hostname"
          }

          rule {
            source_labels = ["__syslog_message_severity"]
            target_label  = "severity"
          }

          rule {
            source_labels = ["facility"]
            target_label  = "facility"
          }

          rule {
            source_labels = ["talos-level"]
            target_label  = "level"
          }

          rule {
            action = "labeldrop"
            regex  = "talos-.*"
          }
        }

        // Listen for Talos service logs on UDP port 6051
        loki.source.syslog "talos_service" {
          listener {
            address                  = "0.0.0.0:6051"
            protocol                 = "udp"
            labels                   = { source = "talos-service" }
            use_incoming_timestamp   = true
            max_message_length       = 102400
          }

          forward_to = [loki.relabel.talos_service_logs.receiver]
        }

        // Listen for Talos kernel logs on UDP port 6050
        loki.source.syslog "talos_kernel" {
          listener {
            address                  = "0.0.0.0:6050"
            protocol                 = "udp"
            labels                   = { source = "talos-kernel" }
            use_incoming_timestamp   = true
            max_message_length       = 102400
          }

          forward_to = [loki.relabel.talos_kernel_logs.receiver]
        }

        // Write logs to Loki
        loki.write "default" {
          endpoint {
            url = "http://loki-gateway.loki.svc.cluster.local/loki/api/v1/push"
            headers = {
              "X-Scope-OrgID" = "prod",
            }
          }
        }
    clustering:
      enabled: false
    mounts:
      varlog: true
    enableHttpServerPort: true
    listenAddr: 0.0.0.0
    listenPort: 12345
    resources:
      requests:
        cpu: 50m
        memory: 64Mi
      limits:
        memory: 256Mi
  controller:
    type: "daemonset"
    hostNetwork: true
    tolerations:
      - key: "node-role.kubernetes.io/control-plane"
        operator: "Exists"
        effect: "NoSchedule"
